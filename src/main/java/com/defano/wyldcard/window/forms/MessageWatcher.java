package com.defano.wyldcard.window.forms;

import com.defano.hypertalk.ast.model.SystemMessage;
import com.defano.wyldcard.parts.Messagable;
import com.defano.wyldcard.runtime.context.ExecutionContext;
import com.defano.wyldcard.window.HyperCardFrame;
import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;

public class MessageWatcher extends HyperCardFrame {

    private final static int MAX_ROWS = 100;

    private JCheckBox supressIdleCheckBox;
    private JPanel windowPanel;
    private JTable messagesTable;
    private JScrollPane scrollPane;
    private JCheckBox supressUnusedCheckBox;

    public MessageWatcher() {
        DefaultTableModel model = new DefaultTableModel();
        model.setColumnCount(2);
        model.setColumnIdentifiers(new Object[]{"Message", "Recipient"});
        messagesTable.setAutoscrolls(true);

        Messagable.addObserver((message, target, trapped) -> {

            if ((!isPeriodicMessage(message) || !supressIdleCheckBox.isSelected()) &&
                    (trapped || !supressUnusedCheckBox.isSelected())) {

                model.addRow(new Object[]{message, target.getHyperTalkIdentifier(new ExecutionContext())});

                if (model.getRowCount() > MAX_ROWS) {
                    model.removeRow(0);
                }

                SwingUtilities.invokeLater(() -> messagesTable.scrollRectToVisible(messagesTable.getCellRect(messagesTable.getRowCount() - 1, 0, true)));
            }
        });

        messagesTable.setModel(model);
    }

    private boolean isPeriodicMessage(String message) {
        return SystemMessage.IDLE.messageName.equalsIgnoreCase(message) ||
                SystemMessage.MOUSE_WITHIN.messageName.equalsIgnoreCase(message);
    }

    @Override
    public JComponent getWindowPanel() {
        return windowPanel;
    }

    @Override
    public void bindModel(Object data) {
        // Nothing to do
    }

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        windowPanel = new JPanel();
        windowPanel.setLayout(new GridLayoutManager(2, 2, new Insets(10, 10, 10, 10), -1, -1));
        supressIdleCheckBox = new JCheckBox();
        supressIdleCheckBox.setSelected(true);
        supressIdleCheckBox.setText("Supress repetitive messages");
        supressIdleCheckBox.setToolTipText("When checked, messages that are sent periodically (like 'idle') will be supressed.");
        windowPanel.add(supressIdleCheckBox, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        scrollPane = new JScrollPane();
        windowPanel.add(scrollPane, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        messagesTable = new JTable();
        messagesTable.setFillsViewportHeight(false);
        Font messagesTableFont = this.$$$getFont$$$("Monaco", Font.PLAIN, 12, messagesTable.getFont());
        if (messagesTableFont != null) messagesTable.setFont(messagesTableFont);
        scrollPane.setViewportView(messagesTable);
        supressUnusedCheckBox = new JCheckBox();
        supressUnusedCheckBox.setText("Show only handeled messages");
        supressUnusedCheckBox.setToolTipText("When checked, only messages for which a handler exist will be shown.");
        windowPanel.add(supressUnusedCheckBox, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
    }

    /**
     * @noinspection ALL
     */
    private Font $$$getFont$$$(String fontName, int style, int size, Font currentFont) {
        if (currentFont == null) return null;
        String resultName;
        if (fontName == null) {
            resultName = currentFont.getName();
        } else {
            Font testFont = new Font(fontName, Font.PLAIN, 10);
            if (testFont.canDisplay('a') && testFont.canDisplay('1')) {
                resultName = fontName;
            } else {
                resultName = currentFont.getName();
            }
        }
        return new Font(resultName, style >= 0 ? style : currentFont.getStyle(), size >= 0 ? size : currentFont.getSize());
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return windowPanel;
    }
}
